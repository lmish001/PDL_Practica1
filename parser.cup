/*
   Simple +/-/* expression language; 
   parser evaluates constant expressions on the fly
*/

package cup.example;

import java_cup.runtime.*;
import cup.example.Lexer;
import java.io.IOException;
import java.io.File;
import java.io.FileInputStream;

parser code {:
  protected Lexer lexer;
:}

/* define how to connect to the scanner! */
init with {:
  ComplexSymbolFactory f = new ComplexSymbolFactory();
  symbolFactory = f;
  File file = new File("input.txt");
  FileInputStream fis = null;
  try {
    fis = new FileInputStream(file);
  } catch (IOException e) {
    e.printStackTrace();
  } 
  lexer = new Lexer(f,fis);
:};
scan with {: return lexer.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal            SEMI, PLUS, MINUS, UMINUS, TIMES, DIVIDEBY, LPAREN, RPAREN;
terminal Integer    INT_NUMBER;       
terminal Float DEC_NUMBER;
/* Non terminals */
non terminal            expr_list;
non terminal Integer    e_int, t_int, f_int, p_int;      // used to store evaluated subexpressions
non terminal Float e_float, t_float, f_float, p_float;
/* Precedences 
precedence left PLUS, MINUS;
precedence left TIMES;
precedence left UMINUS;
*/


/* The grammar rules */
expr_list 	::= expr_list e_int:e SEMI			{: System.out.println(e); :}
				| e_int:e SEMI					{: System.out.println(e); :}
				//| e_int:e						{: System.out.println(e); :}
				| expr_list e_float:e SEMI		{: System.out.println(e); :}
				| e_float:e SEMI				{: System.out.println(e); :}
				//| e_float:e						{: System.out.println(e); :}
				;
/*integer*/
e_int 		::=	e_int:e1 PLUS t_int:e2			{: RESULT = e1+e2;        :}
				| e_int:e1 MINUS t_int:e2		{: RESULT = e1-e2;        :}
				| t_int:e1						{: RESULT = e1;        	:}
				;
				
t_int 		::= t_int:e1 TIMES f_int:e2 		{: RESULT = e1*e2;        :}
				| f_int:e1						{: RESULT = e1;        :}
				;
				
f_int 		::= PLUS INT_NUMBER:e1				{: RESULT = e1;        :}
				| MINUS INT_NUMBER:e1			{: RESULT = -e1;        :}
				| INT_NUMBER:e1					{: RESULT = e1;        :}
				| p_int:e1						{: RESULT = e1;        :}
				;
				
p_int 		::= LPAREN e_int:e1 RPAREN			{: RESULT = e1;        :}
				;
/*float*/
e_float 		::=	e_float:e1 PLUS t_float:e2	{: RESULT = e1+e2;        :}
				| e_float:e1 MINUS t_float:e2	{: RESULT = e1-e2;        :}
				| e_float:e1 PLUS t_int:e2		{: RESULT = e1+e2;        :}
				| e_float:e1 MINUS t_int:e2		{: RESULT = e1-e2;        :}
				| e_int:e1 PLUS t_float:e2		{: RESULT = e1+e2;        :}
				| e_int:e1 MINUS t_float:e2		{: RESULT = e1-e2;        :}
				| t_float:e1					{: RESULT = e1;        	:}
				;
				
t_float 		::= t_float:e1 TIMES f_float:e2 {: RESULT = e1*e2;        :}
				| t_float:e1 DIVIDEBY f_float:e2{: RESULT = e1/e2;        :}
				| t_float:e1 TIMES f_int:e2 	{: RESULT = e1*e2;        :}
				| t_float:e1 DIVIDEBY f_int:e2	{: RESULT = e1/e2;        :}
				| t_int:e1 TIMES f_float:e2 	{: RESULT = e1*e2;        :}
				| t_int:e1 DIVIDEBY f_float:e2	{: RESULT = e1/e2;        :}
				| t_int:e1 DIVIDEBY f_int:e2	{: RESULT = e1.floatValue()/e2.floatValue();        :}
				| f_float:e1					{: RESULT = e1;        :}
				;
				
f_float 		::= PLUS DEC_NUMBER:e1			{: RESULT = e1;        :}
				| MINUS DEC_NUMBER:e1			{: RESULT = -e1;        :}
				| DEC_NUMBER:e1					{: RESULT = e1;        :}
				| p_float:e1					{: RESULT = e1;        :}
				;
				
p_float 		::= LPAREN e_float:e1 RPAREN	{: RESULT = e1;        :}
				;  
				      

       